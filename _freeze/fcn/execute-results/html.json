{
  "hash": "f90df7fbb10df624c534ea97c810580b",
  "result": {
    "engine": "knitr",
    "markdown": "\n# Functional Connectivity {#sec-functional-connectivity}\n\nFunctional connectivity is a measurement of how activity in different regions of the brain are related. It is calculated by reducing the voxelwise timeseries into a set of parceled timecourses and then calculating a measure of connectivity between those timecourses. \n\nThis kit reviews the A2CPS functional connectivity derivatives that have been created by pre-defined parcellations. For functional connectivity derived from independent components, see the GIFT starter kit (forthcoming).\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(arrow)\nlibrary(dplyr)\nlibrary(tidyr)\nlibrary(purrr)\nlibrary(stringr)\nlibrary(readr)\nlibrary(fs)\nlibrary(mgc)\nlibrary(ggplot2)\n```\n:::\n\n\n\n\n\n## Starting Project\n\n### Locate data\n\n\nOn TACC, the neuroimaging data are stored underneath the releases. For example, data release v2.#.# is underneath\n\n```bash\npre-surgery/mris\n```\n\n\n\nThe functional connectivity derivatives are underneath `mris/derivatives/fcn`\n\n```bash\n$ ls mris/derivatives/fcn/\ncleaned  confounds  confounds.json  connectivity  connectivity.json  timeseries  timeseries.json\n```\n\nThe functional connectivity data is in a tabular format in the folder `connectivity`. The A2CPS dataset includes functional connectivity from several atlases, estimated using multiple methods. For details on the atlases, see the data dictionary `connectivity.json`.\n\nTo enable flexibility, the timeseries parcellations are also provided in the folder `timeseries`, with data dictionary `timeseries.json`. These enable analyses such as dynamic connectivity or calculation of alternative measures of connectivity (e.g., partial correlation).\n\nThe tabular data comprise parquet files that have been partitioned in a [hive style](https://hive.apache.org/). That is, subfolder names contain column information (e.g., participant label). \n\n```bash\n$ tree connectivity | head -n 20\nconnectivity\n├── sub=10003\n│   └── ses=V1\n│       ├── task=cuff\n│       │   └── run=1\n│       │       ├── atlas=difumo_dimension-1024_resolution-2mm\n│       │       │   ├── estimator=empirical\n│       │       │   │   └── part-0.parquet\n│       │       │   └── estimator=leodit_wolf\n│       │       │       └── part-0.parquet\n│       │       ├── atlas=difumo_dimension-64_resolution-2mm\n│       │       │   ├── estimator=empirical\n│       │       │   │   └── part-0.parquet\n│       │       │   └── estimator=leodit_wolf\n│       │       │       └── part-0.parquet\n│       │       ├── atlas=dmn\n│       │       │   ├── estimator=empirical\n│       │       │   │   └── part-0.parquet\n│       │       │   └── estimator=leodit_wolf\n│       │       │       └── part-0.parquet\n```\n\nThe timeseries were extracted from the NIfTI files in `cleaned`, which are the outputs of fMRIPrep after band-pass filtering (0.01 - 0.1Hz), quadratic detrending, and nuisance regression (@sadil_acute_2024). The nuisance regressors are stored in the folder `confounds`.\n\n### Extract data\n\nMost users will start with the functional connectivity data. For example, here we grab the connectivity associated with the Default Mode Network (DMN) atlas (the nodal coordinates were derived from @baliki_corticostriatal_2012). In this case, we'll restrict results to connectivities generated with the [empirical estimator](https://scikit-learn.org/stable/modules/generated/sklearn.covariance.EmpiricalCovariance.html#sklearn.covariance.EmpiricalCovariance).\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndmn <- open_dataset(\"data/connectivity\") |> \n  filter(atlas==\"dmn\") |>\n  filter(estimator==\"empirical\") |>\n  select(sub, source, target, connectivity) |>\n  collect() \nhead(dmn)\n```\n\n::: {.cell-output-display}\n<div class=\"kable-table\">\n\n| sub| source| target| connectivity|\n|---:|------:|------:|------------:|\n\n</div>\n:::\n:::\n\n\n\n\nNotice that the `source` and `target` fields are simply integer indices for this atlas. As specified in `connectivity.json`, information about these regions is available in one of the A2CPS GitHub repos. That table can be read directly from a URL.\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndmn_labels <- read_csv(\"https://raw.githubusercontent.com/a2cps/functional_connectivity/3aa91a6c10d14dcc7d1fe9890e7a6db95d2aad8b/src/functional_connectivity/data/baliki.csv\")\ndmn_labels\n```\n\n::: {.cell-output-display}\n<div class=\"kable-table\">\n\n| region|label   |   x|   y|  z|\n|------:|:-------|---:|---:|--:|\n|      1|mPFC    |   2|  52| -2|\n|      2|rNAC    |  10|  12| -8|\n|      3|rInsula |  40|  -6| -2|\n|      4|S1/M1   | -32| -34| 66|\n\n</div>\n:::\n:::\n\n\n\n\nAfter reading in the labels, they can be merged with the functional connectivity results. \n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndmn_labeled <- dmn |>\n  left_join(dmn_labels, by = join_by(source==region)) |>\n  select(-source, -x, -y, -z) |>\n  rename(source=label) |>\n  left_join(dmn_labels, by = join_by(target==region)) |>\n  select(-target, -x, -y, -z) |>\n  rename(target=label)\n\nhead(dmn_labeled)\n```\n\n::: {.cell-output-display}\n<div class=\"kable-table\">\n\n|   sub| connectivity|source  |target  |\n|-----:|------------:|:-------|:-------|\n| 10003|    0.0636924|mPFC    |rNAC    |\n| 10003|   -0.1188529|mPFC    |rInsula |\n| 10003|   -0.4824537|mPFC    |S1/M1   |\n| 10003|    0.1341398|rNAC    |rInsula |\n| 10003|   -0.0532711|rNAC    |S1/M1   |\n| 10003|    0.2889038|rInsula |S1/M1   |\n\n</div>\n:::\n:::\n\n\n\n\n\n## Considerations While Working on the Project\n\n### Variability Across Scanners\n\n\nMany MRI biomarkers exhibit variability across the scanners, which may confound some analyses. For an up-to-date assessment of the issue and overview of current thinking, please see [Confluence](https://a2cps.atlassian.net/wiki/spaces/DOC/pages/176619539/Imaging+Harmonization). \n\n\n\n### Data Quality\n\n\nAs with any MRI derivative, all pipeline derivatives have been included. This means that products were included regardless of their quality, and so some products may have been generated from images that are known to have poor quality---rated \"red\", or incomparable. For details on the ratings and how to exclude them, see @sec-rawdata-mri-qc-joining. Additionally, extensive QC has not yet been performed on the derivatives themselves, and so there may be cases where pipelines produced atypical outputs. For an overview of planned checks, see [Confluence](https://a2cps.atlassian.net/wiki/spaces/DOC/pages/262471688/Image+Processing+Checks). \n\n\n\n### Example Analysis: Discriminability\n\nIn this section, we show how the connectivity results could be used to calculate discriminability [@bridgeford_eliminating_2021], which is a multivariate measure of replicability like the intra-class correlation coefficient or fingerprinting. Discriminability ranges from 0 - 1, with 0.5 indicating something like an equal chance that the two scans from the same participants are as similar as the two scans from different participants, and 1 indicating that the two scans from the same participant are always more similar than two scans from differing participants.\n\nWe are going to assess whether a person's connectivity matrix is consistent across runs, even across runs of different types (e.g., CUFF1 vs CUFF2, REST1 vs CUFF1).\n\nFirst, we need a list of participants that have all four scan types.\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsubs_with_all_runs <- open_dataset(\"data/connectivity\") |>\n  distinct(sub, task, run) |>\n  count(sub) |>\n  filter(n==4) |>\n  select(sub) |>\n  collect()\n```\n:::\n\n\n\n\nAs usual, we should also restrict analyses to only those runs that are not \"red\".\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nred_fmri <- read_tsv(dir_ls(\"data/scans\", glob = \"*tsv\"), na = \"n/a\") |>\n  filter(str_detect(filename, \"task\")) |>\n  filter(rating==\"red\") |>\n  mutate(\n    sub = str_extract(filename, \"(?<=sub-)[[:digit:]]{5}\") |>\n      as.integer()\n  ) |>\n  distinct(sub)\nhead(red_fmri)\n```\n\n::: {.cell-output-display}\n<div class=\"kable-table\">\n\n|   sub|\n|-----:|\n| 10049|\n| 10058|\n| 10060|\n| 10074|\n| 10086|\n| 10092|\n\n</div>\n:::\n:::\n\n\n\n\nOf the list of participants with all four functional scans, filter out the participants for which any of the scans were red.\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsubs_with_all_runs_ok <- subs_with_all_runs |>\n  anti_join(red_fmri)\n```\n:::\n\n\n\n\nUse this to filter the connectivity results. We'll select just one of the smaller DiFuMo atlases [@dadi_fine_2020]. As before, we'll stick with the empirical estimator.\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nfcn <- open_dataset(\"data/connectivity\") |> \n  filter(atlas==\"difumo_dimension-64_resolution-2mm\") |>\n  filter(estimator==\"empirical\") |>\n  semi_join(subs_with_all_runs_ok, by = join_by(sub)) |>\n  mutate(scan = str_c(task, run)) |>\n  select(-atlas, -ses, -task, -run, -estimator) |>\n  collect() \nhead(fcn)\n```\n\n::: {.cell-output-display}\n<div class=\"kable-table\">\n\n| source| target| connectivity|   sub|scan  |\n|------:|------:|------------:|-----:|:-----|\n|      1|     10|    0.0591276| 10010|cuff2 |\n|      1|     11|    0.0573687| 10010|cuff2 |\n|      1|     12|    0.2145623| 10010|cuff2 |\n|      1|     13|   -0.3082481| 10010|cuff2 |\n|      1|     14|   -0.1808573| 10010|cuff2 |\n|      1|     15|    0.1516730| 10010|cuff2 |\n\n</div>\n:::\n:::\n\n\n\n\nNext, define some helper functions to break up the different parts of the analysis pipeline.\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nget_scan_combinations <- function(\n    scans=c(\"rest1\", \"rest2\", \"cuff1\", \"cuff2\"), \n    .col1=scan1, \n    .col2=scan2){\n  combn(scans, 2) |>\n    t() |>\n    as_tibble() |>\n    rename({{.col1}}:=V1, {{.col2}}:=V2) \n}\n\njoin_fcn_to_combinations <- function(.data, fcn){\n  fcn_nested <- group_nest(fcn, scan)\n  .data |>\n    left_join(fcn_nested, by = join_by(scan1==scan)) |>\n    left_join(fcn_nested, by = join_by(scan2==scan)) |>\n    mutate(\n      data = map2(\n        data.x, data.y, \n        ~left_join(.x, .y, by=join_by(source, target, sub)))\n    ) |>\n    select(-starts_with(\"data.\"))\n}\n\nget_discr <- function(.data){\n  d <- .data |>\n    mutate(feature=interaction(source, target)) |> \n    select(-source, -target) |> \n    pivot_longer(starts_with(\"connectivity\")) |> \n    pivot_wider(names_from = \"feature\")\n  \n  discr.stat(\n    as.matrix(select(d, -sub, -name)),\n    as.matrix(select(d, sub))\n  )$discr\n}\n```\n:::\n\n\n\n\nApply these helper functions to the functional connectivity data, calculating discriminability.\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndiscriminability <- get_scan_combinations() |>\n  join_fcn_to_combinations(fcn) |>\n  mutate(discr = map_dbl(data, get_discr)) |>\n  select(-data)\n```\n:::\n\n\n\n\nTo review the results, plot the data. When plotting, let's color the points based on whether the two scans are of the same type.\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndiscriminability |>\n  mutate(\n    same_type = (str_detect(scan1, \"rest\") & str_detect(scan2, \"rest\")) |\n      (str_detect(scan1, \"cuff\") & str_detect(scan2, \"cuff\")),\n    scans = interaction(scan1, scan2)\n  ) |>\n  ggplot(aes(x=scans, y=discr, color=same_type)) +\n  geom_point() +\n  coord_flip() +\n  ylim(0, 1)\n```\n\n::: {.cell-output-display}\n![](fcn_files/figure-html/unnamed-chunk-11-1.png){width=672}\n:::\n:::\n\n\n\n\nOverall, discriminability is around 0.8, with at most minor differences between different pairings of runs.\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}