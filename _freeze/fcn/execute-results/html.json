{
  "hash": "3f25cb853640119e2384bfbf42877452",
  "result": {
    "engine": "knitr",
    "markdown": "\n# Functional Connectivity {#sec-functional-connectivity}\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(arrow)\nlibrary(dplyr)\nlibrary(tidyr)\nlibrary(purrr)\nlibrary(stringr)\nlibrary(readr)\nlibrary(ggplot2)\n```\n:::\n\n\n\n\n\n## Starting Project\n\n### Locate data\n\n\nOn TACC, the neuroimaging data are stored underneath the releases. For example, data release v2.#.# is underneath\n\n```bash\npre-surgery/mris\n```\n\n\n\nThe functional connectivity derivatives are underneath `derivatives/fcn`\n\n```bash\n$ ls derivatives/fcn/\ncleaned  confounds  confounds.json  connectivity  connectivity.json  timeseries  timeseries.json\n```\n\nThe functional connectivity data is in a tabular format in the folder `connectivity`. The A2CPS dataset includes functional connectivity from several atlases, estimated using multiple methods. For details on the atlases, see the data dictionary `connectivity.json`.\n\nTo enable flexibility, the timeseries parcellations are also provided in the folder `timeseries`, with data dictionary `timeseries.json`. These enable analyses such as dynamic connectivity or calculation of alternative measures of connectivity (e.g., partial correlation).\n\nThe timeseries were extracted from the NIfTI files in `cleaned`, which are the outputs of fMRIPrep after band-pass filtering (0.01 - 0.1Hz), quadratic detrending, and nuisance regression (@sadil_acute_2024). The nuisance regressors are stored in the folder `confounds`. \n\n### Extract data\n\nMost users will start with the functional connectivity data. For example, here we grab all \n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndmn <- open_dataset(\"data/connectivity\") |> \n  filter(atlas==\"dmn\") |>\n  filter(estimator==\"leodit_wolf\") |>\n  select(sub, source, target, connectivity) |>\n  collect() \nhead(dmn)\n```\n\n::: {.cell-output-display}\n<div class=\"kable-table\">\n\n|   sub| source| target| connectivity|\n|-----:|------:|------:|------------:|\n| 10008|      1|      2|    0.3433423|\n| 10008|      1|      3|    0.1176422|\n| 10008|      1|      4|    0.2286231|\n| 10008|      2|      3|    0.1761649|\n| 10008|      2|      4|   -0.0535801|\n| 10008|      3|      4|   -0.1632099|\n\n</div>\n:::\n:::\n\n\n\n\nNotice that the `source` and `target` fields are simply integer indices for this atlas. As specified in `connectivity.json`, information about these regions is available in one of the A2CPS GitHub repos. That table can be read directly from a URL.\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndmn_labels <- read_csv(\"https://raw.githubusercontent.com/a2cps/functional_connectivity/3aa91a6c10d14dcc7d1fe9890e7a6db95d2aad8b/src/functional_connectivity/data/baliki.csv\")\ndmn_labels\n```\n\n::: {.cell-output-display}\n<div class=\"kable-table\">\n\n| region|label   |   x|   y|  z|\n|------:|:-------|---:|---:|--:|\n|      1|mPFC    |   2|  52| -2|\n|      2|rNAC    |  10|  12| -8|\n|      3|rInsula |  40|  -6| -2|\n|      4|S1/M1   | -32| -34| 66|\n\n</div>\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\ndmn_labeled <- dmn |>\n  left_join(dmn_labels, by = join_by(source==region)) |>\n  select(-source, -x, -y, -z) |>\n  rename(source=label) |>\n  left_join(dmn_labels, by = join_by(target==region)) |>\n  select(-target, -x, -y, -z) |>\n  rename(target=label)\n```\n:::\n\n\n\n\n\n## Considerations While Working on the Project\n\n### Variability Across Scanners\n\n\nMany MRI biomarkers exhibit variability across the scanners, which may confound some analyses. The imaging DIRC is quantifying and mitigating this variability. For an ongoing review of the issue, please see [Confluence](https://a2cps.atlassian.net/wiki/spaces/DOC/pages/176619539/Imaging+Harmonization). \n\n\n\n### Data Quality\n\n\nAs with any MRI derivative, all pipeline derivatives have been included. This means that products were included regardless of their quality, and so some products may have been generated from images that are known to have poor quality--rated \"red\" or incomparable. For details on the ratings and how to exclude them, see @sec-rawdata-mri-qc-joining. Additionally, extensive QC has not yet been performed on the derivatives themselves, and so there may be cases where pipelines produced atypical outputs. For an overview of planned checks, see [Confluence](https://a2cps.atlassian.net/wiki/spaces/DOC/pages/262471688/Image+Processing+Checks). \n\n\n\n### Example Analysis: Discriminability\n\nIn this section, we show how the connectivity results could be used to calculate discriminability, which is like a kind of multivariate measure of replicability, like the intra-class correlation coefficient or fingerprinting [@bridgeford_eliminating_2021]. We are going to assess whether a person's connectivity matrix is consistent across runs, even across runs of different types (e.g., CUFF1 vs CUFF2, REST1 vs CUFF1).\n\nFirst, we need a list of participants that have all four scan types.\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsubs_with_all_runs <- open_dataset(\"data/connectivity\") |>\n  distinct(sub, task, run) |>\n  count(sub) |>\n  filter(n==4) |>\n  select(sub)\n```\n:::\n\n\n\n\nAs usual, we should also restrict analyses to only those runs that are not \"red\".\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nred_fmri <- read_tsv(fs::dir_ls(\"data/scans\", glob = \"*tsv\"), na = \"n/a\") |>\n  filter(str_detect(filename, \"task\")) |>\n  filter(rating==\"red\") |>\n  mutate(\n    sub = str_extract(filename, \"(?<=sub-)[[:digit:]]{5}\") |>\n      as.integer()\n  ) |>\n  distinct(sub)\nred_fmri\n```\n\n::: {.cell-output-display}\n<div class=\"kable-table\">\n\n|   sub|\n|-----:|\n| 10049|\n| 10058|\n| 10060|\n| 10074|\n| 10086|\n| 10092|\n| 10094|\n| 10095|\n| 10097|\n| 10104|\n| 10105|\n| 10112|\n| 10134|\n| 10149|\n| 10180|\n| 10182|\n| 10189|\n| 10196|\n| 10197|\n| 10202|\n| 10212|\n| 10218|\n| 10220|\n| 10238|\n| 10244|\n| 10258|\n| 10270|\n| 10280|\n| 10285|\n| 10291|\n| 10292|\n| 10302|\n| 10305|\n| 10320|\n| 10321|\n| 10327|\n| 10335|\n| 10349|\n| 10355|\n| 10362|\n| 10363|\n| 10393|\n| 10394|\n| 10397|\n| 10398|\n| 10402|\n| 10408|\n| 10411|\n| 10428|\n| 10431|\n| 10476|\n| 10478|\n| 10495|\n| 10513|\n| 10519|\n| 10520|\n| 10523|\n| 10559|\n| 10586|\n| 10588|\n| 10606|\n| 15003|\n| 20004|\n| 20016|\n| 20018|\n| 20019|\n| 20023|\n| 20024|\n| 20035|\n| 20040|\n| 20046|\n| 20061|\n| 20068|\n| 20078|\n| 20108|\n| 20171|\n| 20191|\n| 20214|\n| 20227|\n| 20230|\n| 25027|\n| 25029|\n| 25081|\n\n</div>\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nsubs_with_all_runs_ok <- subs_with_all_runs |>\n  anti_join(red_fmri)\n```\n:::\n\n\n\n\n\nUse this to filter the connectivity results. We'll select just one of the smaller DiFuMo atlases [@dadi_fine_2020], and rely on connectivities estimated with the Ledoit-Wolf estimator [@ledoit_well_2004]. This analysis can be slow, and so we will run it for only 100 participants. \n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nfcn <- open_dataset(\"data/connectivity\") |> \n  filter(atlas==\"difumo_dimension-64_resolution-2mm\") |>\n  filter(estimator==\"leodit_wolf\") |> # sic\n  semi_join(subs_with_all_runs_ok, by = join_by(sub)) |>\n  mutate(scan = stringr::str_c(task, run)) |>\n  select(-atlas, -estimator, -ses, -task, -run) |>\n  collect() \nhead(fcn)\n```\n\n::: {.cell-output-display}\n<div class=\"kable-table\">\n\n| source| target| connectivity|   sub|scan  |\n|------:|------:|------------:|-----:|:-----|\n|      1|     10|    0.0281701| 10011|rest2 |\n|      1|     11|    0.3872222| 10011|rest2 |\n|      1|     12|    0.7531632| 10011|rest2 |\n|      1|     13|    0.6413313| 10011|rest2 |\n|      1|     14|    0.0154408| 10011|rest2 |\n|      1|     15|    0.0485602| 10011|rest2 |\n\n</div>\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nget_disc <- function(.data){\n  d <- .data |>\n    mutate(feature=interaction(source, target)) |> \n    select(-source, -target) |> \n    pivot_longer(starts_with(\"connectivity\")) |> \n    pivot_wider(names_from = \"feature\")\n  mgc::discr.stat(\n    as.matrix(select(d, -sub, -name)),\n    as.matrix(select(d, sub))\n  )$discr\n}\n\ngroups <- combn(c(\"rest1\", \"rest2\", \"cuff1\", \"cuff2\"), 2) |>\n  t() |>\n  as_tibble() |>\n  rename(scan1=V1, scan2=V2) |>\n  left_join(fcn |> group_nest(scan), by = join_by(scan1==scan)) |>\n  left_join(fcn |> group_nest(scan), by = join_by(scan2==scan)) |>\n  mutate(\n    data = map2(\n      data.x, data.y, \n      ~left_join(.x, .y, by=join_by(source, target, sub)))\n  ) |>\n  select(-starts_with(\"data.\")) |>\n  mutate(\n    discr = map_dbl(data, get_disc)\n  ) |>\n  select(-data)\n```\n:::\n\n\n\n\nDiscriminability ranges from 0 - 1, with 0.5 indicating something like an equal chance that the two scans from the same participants are as similar as the two scans from different participants, and 1 indicating that the two scans from the same participant are always more similar than two scans from differing participants.\n\nWhen plotting, let's color the points based on whether the two scans are of the same type.\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ngroups |>\n  mutate(\n    same_type = (str_detect(scan1, \"rest\") & str_detect(scan2, \"rest\")) |\n      (str_detect(scan1, \"cuff\") & str_detect(scan2, \"cuff\")),\n    scans = interaction(scan1, scan2)\n  ) |>\n  ggplot(aes(x=scans, y=discr, color=same_type)) +\n  geom_point() +\n  coord_flip() +\n  ylim(0, 1)\n```\n\n::: {.cell-output-display}\n![](fcn_files/figure-html/unnamed-chunk-10-1.png){width=672}\n:::\n:::\n\n\n\n\nOverall, discriminability is very high, with at most minor differences between pairings of runs.\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}